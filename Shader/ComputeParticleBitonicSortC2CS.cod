//
// Generated by Microsoft (R) HLSL Shader Compiler 10.1
//
//
// Buffer Definitions: 
//
// cbuffer COMPUTE_PARTICLE_BITONIC_SORT_CONSTANT_BUFFER
// {
//
//   uint increment;                    // Offset:    0 Size:     4
//   uint direction;                    // Offset:    4 Size:     4
//   uint sortDummy[2];                 // Offset:   16 Size:    20 [unused]
//
// }
//
// Resource bind info for particleHeaderBuffer
// {
//
//   struct ParticleHeader
//   {
//       
//       uint alive;                    // Offset:    0
//       uint particleIndex;            // Offset:    4
//       float depth;                   // Offset:    8
//       uint dummy;                    // Offset:   12
//
//   } $Element;                        // Offset:    0 Size:    16
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// particleHeaderBuffer                  UAV  struct         r/w             u3      1 
// COMPUTE_PARTICLE_BITONIC_SORT_CONSTANT_BUFFER    cbuffer      NA          NA           cb11      1 
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Input
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Output
cs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB11[1], immediateIndexed
dcl_uav_structured u3, 16
dcl_input vThreadID.x
dcl_temps 4
dcl_tgsm_structured g0, 16, 1024
dcl_thread_group 512, 1, 1
ishl r0.x, vThreadID.x, l(1)
mov r0.yz, cb11[0].xxxx
loop 
  ige r0.w, l(0), r0.z
  breakc_nz r0.w
  iadd r0.w, r0.z, l(-1)
  and r0.w, r0.w, vThreadID.x
  iadd r0.w, -r0.w, r0.x
  and r1.x, r0.w, cb11[0].y
  ieq r1.y, r0.y, r0.z
  if_nz r1.y
    ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r2.xyzw, r0.w, l(0), u3.xzyw
    iadd r1.y, r0.z, r0.w
    ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r3.xyzw, r1.y, l(0), u3.xzyw
  else 
    sync_g_t
    and r1.y, r0.w, l(1023)
    ld_structured r2.xyzw, r1.y, l(0), g0.xzyw
    iadd r1.y, r0.z, r0.w
    and r1.y, r1.y, l(1023)
    ld_structured r3.xyzw, r1.y, l(0), g0.xzyw
  endif 
  movc r1.x, r1.x, l(0), l(1)
  ult r1.y, r3.x, r2.x
  ieq r1.z, r2.x, r3.x
  lt r1.w, r3.y, r2.y
  and r1.z, r1.w, r1.z
  or r1.y, r1.z, r1.y
  and r1.y, r1.y, l(1)
  xor r1.x, r1.y, r1.x
  swapc r1.xyzw, r2.xyzw, r1.xxxx, r3.xzyw, r2.xzyw
  ieq r3.x, r0.z, l(1)
  if_nz r3.x
    store_structured u3.xyzw, r0.w, l(0), r2.xyzw
    iadd r3.x, r0.w, l(1)
    store_structured u3.xyzw, r3.x, l(0), r1.xyzw
  else 
    sync_g_t
    and r3.x, r0.w, l(1023)
    store_structured g0.xyzw, r3.x, l(0), r2.xyzw
    iadd r0.w, r0.z, r0.w
    and r0.w, r0.w, l(1023)
    store_structured g0.xyzw, r0.w, l(0), r1.xyzw
  endif 
  ishr r0.z, r0.z, l(1)
endloop 
ret 
// Approximately 47 instruction slots used
